<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libparanut: Spinlock Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libparanut
   </div>
   <div id="projectbrief">A Hardware Abstraction Layer for ParaNut Architectures.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Spinlock Module<div class="ingroups"><a class="el" href="group__mo.html">libparanut Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions and structure used for synchronizing memory access.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Spinlock Module:</div>
<div class="dyncontent">
<div class="center"><img src="group__sp.png" border="0" usemap="#agroup____sp" alt=""/></div>
<map name="agroup____sp" id="agroup____sp">
<area shape="rect" href="group__mo.html" title="Modules of libparanut." alt="" coords="5,5,152,31"/>
<area shape="rect" title="Functions and structure used for synchronizing memory access." alt="" coords="200,5,329,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____pn__spinlock.html">__pn_spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronization primitive. Use <a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> instead of this.  <a href="struct____pn__spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabecb76f9c812a18a14e433cce443c16b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init</a> (<a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *spinlock)</td></tr>
<tr class="memdesc:gabecb76f9c812a18a14e433cce443c16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lock.  <a href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">More...</a><br /></td></tr>
<tr class="separator:gabecb76f9c812a18a14e433cce443c16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636e11171022a37ef7925b057609c04a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sp.html#ga636e11171022a37ef7925b057609c04a">pn_spinlock_lock</a> (<a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *spinlock)</td></tr>
<tr class="memdesc:ga636e11171022a37ef7925b057609c04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a lock. Forever, if it must. Use with caution.  <a href="group__sp.html#ga636e11171022a37ef7925b057609c04a">More...</a><br /></td></tr>
<tr class="separator:ga636e11171022a37ef7925b057609c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfced56684e4570ebd4c3a828ab5db8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sp.html#gacfced56684e4570ebd4c3a828ab5db8d">pn_spinlock_trylock</a> (<a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *spinlock)</td></tr>
<tr class="memdesc:gacfced56684e4570ebd4c3a828ab5db8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire a lock. Nonblocking.  <a href="group__sp.html#gacfced56684e4570ebd4c3a828ab5db8d">More...</a><br /></td></tr>
<tr class="separator:gacfced56684e4570ebd4c3a828ab5db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e7b2cb2a8cc93fbc396a32d7a8be98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sp.html#gad6e7b2cb2a8cc93fbc396a32d7a8be98">pn_spinlock_unlock</a> (<a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *spinlock)</td></tr>
<tr class="memdesc:gad6e7b2cb2a8cc93fbc396a32d7a8be98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a lock.  <a href="group__sp.html#gad6e7b2cb2a8cc93fbc396a32d7a8be98">More...</a><br /></td></tr>
<tr class="separator:gad6e7b2cb2a8cc93fbc396a32d7a8be98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94971694fc9f15ab4b70ccf2f3d6064e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sp.html#ga94971694fc9f15ab4b70ccf2f3d6064e">pn_spinlock_destroy</a> (<a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *spinlock)</td></tr>
<tr class="memdesc:ga94971694fc9f15ab4b70ccf2f3d6064e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a lock.  <a href="group__sp.html#ga94971694fc9f15ab4b70ccf2f3d6064e">More...</a><br /></td></tr>
<tr class="separator:ga94971694fc9f15ab4b70ccf2f3d6064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions and structure used for synchronizing memory access. </p>
<dl class="section warning"><dt>Warning</dt><dd>The functions in here are really kinda performance critical, since it is always important to do as little as possible when you have reserved a memory area. This means that the functions will do extremly little security checks, which means you have to use them the way they are described. Read the detailed descriptions of the functions carefully. Or don't. I'm not the coding police.</dd>
<dd>
Using the spinlock functions in linked Mode (see <a class="el" href="group__li.html">Link Module</a> and <a class="el" href="group__ms.html">Modes</a>) results in undefined behaviour.</dd>
<dd>
If you want to use the Spinlock Module on RISC-V ParaNut, your ParaNut has to support the A Extension and you have to compile your application with the flag mabi=rv32ia. The libparanut <a class="el" href="Makefile.html">Makefile</a> sets this flag automatically when you chose the <a class="el" href="group__sp.html">Spinlock Module</a> or one of the Modules that has <a class="el" href="group__sp.html">Spinlock Module</a> as a dependency.</dd></dl>
<p>Return value of functions is always error code, except when stated otherwise in the description of the function. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga94971694fc9f15ab4b70ccf2f3d6064e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94971694fc9f15ab4b70ccf2f3d6064e">&#9670;&nbsp;</a></span>pn_spinlock_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pn_spinlock_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *&#160;</td>
          <td class="paramname"><em>spinlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a lock. </p>
<p>Behaviour of this function is undefined if the lock wasn't initialized by <a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init()</a>.</p>
<p>A destroyed lock can be re-initialized by using <a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init()</a>.</p>
<p>The lock can either be owned by current hart or unlocked, else the function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinlock</td><td>is a pointer to a lock that we want to destroy. The function will return <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a> if NULL is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <a class="el" href="group__er.html#ga5d8b16ffb32e1abf285f5a256aeede23">PN_SUCCESS</a>, <a class="el" href="group__er.html#ga83807d4157a584d00519c3324a123b0e">PN_ERR_LOCKOCC</a> or <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>. If something internally went very wrong, the function is also theoretically able to return <a class="el" href="group__er.html#ga7fa757e1c8320021b0f75d0065b658ab">PN_ERR_NOIMP</a>. </dd></dl>

</div>
</div>
<a id="gabecb76f9c812a18a14e433cce443c16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabecb76f9c812a18a14e433cce443c16b">&#9670;&nbsp;</a></span>pn_spinlock_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pn_spinlock_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *&#160;</td>
          <td class="paramname"><em>spinlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a lock. </p>
<p>You allocate the space for the spinlock. Really don't care where you get it from (check <a class="el" href="struct____pn__spinlock.html">__pn_spinlock</a> for a recommendation). You pass a reference to this function, and the function initializes it for you. And you shall never touch what's in it.</p>
<p>Afterwards, you can use the other functions in this module on the same lock. Behaviour will always be undefined if you don't call this function first.</p>
<p>The function does not care if your lock was already initialized. It will fail if the CPU did not get the memory reservation (<a class="el" href="group__er.html#ga83807d4157a584d00519c3324a123b0e">PN_ERR_LOCKOCC</a>), which should never happen. This is a very good indicator that something is very wrong with your program.</p>
<p>After initialization, the lock is free. It will not be automatically owned by the hart that initialized it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinlock</td><td>is a pointer to the lock. The function will return <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a> if NULL is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <a class="el" href="group__er.html#ga5d8b16ffb32e1abf285f5a256aeede23">PN_SUCCESS</a>, <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>, or <a class="el" href="group__er.html#ga83807d4157a584d00519c3324a123b0e">PN_ERR_LOCKOCC</a>. If something internally went very wrong, the function is also theoretically able to return <a class="el" href="group__er.html#ga7fa757e1c8320021b0f75d0065b658ab">PN_ERR_NOIMP</a>. </dd></dl>

</div>
</div>
<a id="ga636e11171022a37ef7925b057609c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga636e11171022a37ef7925b057609c04a">&#9670;&nbsp;</a></span>pn_spinlock_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pn_spinlock_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *&#160;</td>
          <td class="paramname"><em>spinlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a lock. Forever, if it must. Use with caution. </p>
<p>Behaviour of this function is undefined if the lock wasn't initialized by <a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function will be stuck in eternity if the lock is already in the current harts posession, or if someone else owns the lock and forgot to unlock it, or if the lock was destroyed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinlock</td><td>is a pointer to a lock that we want to aquire. The function will return <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a> if NULL is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <a class="el" href="group__er.html#ga5d8b16ffb32e1abf285f5a256aeede23">PN_SUCCESS</a> or <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>. </dd></dl>

</div>
</div>
<a id="gacfced56684e4570ebd4c3a828ab5db8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfced56684e4570ebd4c3a828ab5db8d">&#9670;&nbsp;</a></span>pn_spinlock_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pn_spinlock_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *&#160;</td>
          <td class="paramname"><em>spinlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to acquire a lock. Nonblocking. </p>
<p>Behaviour of this function is undefined if the lock wasn't initialized by <a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init()</a>.</p>
<p>Will fail if lock is already owned (no matter by whom), another CPU got the memory reservation, or if lock was destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinlock</td><td>is a pointer to a lock that we want to aquire. The function will return <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a> if NULL is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <a class="el" href="group__er.html#ga5d8b16ffb32e1abf285f5a256aeede23">PN_SUCCESS</a>, <a class="el" href="group__er.html#ga83807d4157a584d00519c3324a123b0e">PN_ERR_LOCKOCC</a> or <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>. If something internally went very wrong, the function is also theoretically able to return <a class="el" href="group__er.html#ga7fa757e1c8320021b0f75d0065b658ab">PN_ERR_NOIMP</a>. </dd></dl>

</div>
</div>
<a id="gad6e7b2cb2a8cc93fbc396a32d7a8be98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6e7b2cb2a8cc93fbc396a32d7a8be98">&#9670;&nbsp;</a></span>pn_spinlock_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pn_spinlock_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ty.html#ga9c816f2e7868c4f9149591cdc497cac9">_pn_spinlock</a> *&#160;</td>
          <td class="paramname"><em>spinlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a lock. </p>
<p>Behaviour of this function is undefined if the lock wasn't initialized by <a class="el" href="group__sp.html#gabecb76f9c812a18a14e433cce443c16b">pn_spinlock_init()</a>.</p>
<p>Will fail is lock is not owned by current hart (<a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinlock</td><td>is a pointer to a lock that we want to unlock. The function will return <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a> if NULL is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <a class="el" href="group__er.html#ga5d8b16ffb32e1abf285f5a256aeede23">PN_SUCCESS</a> or <a class="el" href="group__er.html#ga79d927862dc5bcded0f822c35cd3da7c">PN_ERR_PARAM</a>. If something internally went very wrong, the function is also theoretically able to return <a class="el" href="group__er.html#ga7fa757e1c8320021b0f75d0065b658ab">PN_ERR_NOIMP</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
